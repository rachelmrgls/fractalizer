#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
precision mediump int;
uniform mat4 uMVMatrix;

uniform float iGlobalTime;

// some constant        
#define INFINITY 1.0e+12
#define EPS 1.0e-3
#define M_PI 3.1415926535897932384626433832795

// some scene 
#define MAX_OBJECTS 20
#define MAX_LIGHTS 10
#define MAX_STEPS 50
#define MAX_MANDEL_ITER 1024

#define INFSPHERE 1
#define SPHERE 2
#define MENGER 3
#define JULIA 4
#define MANDELBROT 5

struct Shape {
    int shapeType;
    vec3 v1;
    vec3 v2;
    float rad;
};

#define NONE 0
#define CHECKERBOARD 1
#define MYSPECIAL 2

#define BASICMATERIAL 1
#define PHONGMATERIAL 2
#define LAMBERTMATERIAL 3

#define NONEREFLECT 1
#define MIRRORREFLECT 2
#define GLASSREFLECT 3

struct Material {
    int materialType;
    vec3 color;
    float shininess;
    vec3 specular;

    int materialReflectType;
    float reflectivity; 
    float refractionRatio;
    int special;

};

struct Object {
    Shape shape;
    Material material;
};

struct Light {
    vec3 position;
    vec3 color;
    float intensity;
    float attenuate;
};

//uniform float data0;
//uniform int audio[3];
uniform float value;
uniform sampler2D audio;
uniform int frame;        
uniform float height;
uniform float width;
uniform vec3 camera;
uniform int numObjects;
uniform int numLights;
uniform Object objects[MAX_OBJECTS];
uniform Light lights[MAX_LIGHTS];
uniform vec3 objectNorm;

varying vec2 v_position;
float iter;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Intersection {
    vec3 position;
    vec3 normal;
    int steps;
};

// find then position some distance along a ray
vec3 rayGetOffset( Ray ray, float dist ) {
    return ray.origin + ( dist * ray.direction );
}

// if a newly found intersection is closer than the best found so far, record the new intersection and return true;
// otherwise leave the best as it was and return false.
bool chooseCloserIntersection(float dist, inout float best_dist, inout Intersection intersect, inout Intersection best_intersect) {
    if (best_dist <= dist) return false;
    best_dist = dist;
    best_intersect.position = intersect.position;
    best_intersect.normal   = intersect.normal;
    best_intersect.steps    = intersect.steps;
    return true;
}


// sphere/cylinder/cone extraction
vec3  getShapeCenter(Shape shape)      { return shape.v2; }
float getShapeRadius(Shape shape)      { return shape.rad; }


#define MAX_RECURSION 20

// pseudorandom number generator from precept 9 slide 15
// range is [0 1]
float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

vec3 calcSpecularColor(Object obj, vec3 posIntersection, vec3 normalVector, vec3 eyeVector, bool phongOnly) {
	
    vec3 diffuseColor;

    if (obj.shape.shapeType == MANDELBROT) {
        diffuseColor = vec3(iter,iter,iter);
    } else {
        diffuseColor = obj.material.color;
    }


	vec3 outputColor = vec3( 0.0, 0.0, 0.0 ); // color defaults to black	
	
    for (int i=0; i<MAX_LIGHTS; i++) {

        if(i>=numLights) break; // because GLSL will not allow looping to numLights
		
        vec3 lightVector = lights[i].position - posIntersection;
        //if ( pointInShadow( lights[i].position, lightVector ) ) continue;

        // add color to output color for each light, based on material type
        if (obj.material.materialType == BASICMATERIAL) {
            outputColor += diffuseColor;
        } 
        else if (obj.material.materialType == PHONGMATERIAL || 
                 obj.material.materialType == LAMBERTMATERIAL) {
            // get light attenuation
            float dist = length(lightVector);
            float attenuation = lights[i].attenuate * dist * dist;

            float diffuseIntensity = max(0.0, dot(normalVector, lightVector)) * lights[i].intensity;
            
            // glass and mirror objects have specular highlights but no diffuse lighting
            if (!phongOnly) {
                outputColor += (diffuseColor * lights[i].color) * diffuseIntensity / attenuation; 
            }
            
            if (obj.material.materialType == PHONGMATERIAL) {
                // ----------- STUDENT CODE BEGIN ------------
                vec3 phongTerm = vec3( 0.0, 0.0, 0.0 ); // not implemented yet, so just add black   

                if (dot(normalVector, lightVector) > -EPS) {
                    vec3 Lhat = normalize(lightVector);
                    vec3 Nhat = normalize(normalVector);
                    vec3 Rhat = normalize(2.0 * dot(Lhat,Nhat) * Nhat - Lhat);
                    vec3 Vhat = normalize(camera - eyeVector);

                    float tmp = dot(Rhat,Vhat);
                    if (tmp > EPS) {
                        phongTerm += obj.material.specular * pow(tmp,obj.material.shininess) * lights[i].intensity / (attenuation / 50.0);
                    }
                }
                // ----------- STUDENT CODE END ------------
                outputColor += phongTerm;
            }
        }
	}
	
	return outputColor;
}

float sphere_de( vec3 p, float r ) {
    return sqrt( dot( p, p ) ) - r;
}

// Created by inigo quilez - iq/2013
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
float maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}

float sdBox( vec3 p, vec3 b ) {
  vec3  di = abs(p) - b;
  float mc = maxcomp(di);
  return min(mc,length(max(di,0.0)));
}

mat3 ma = mat3( 0.60, 0.00,  0.80,
                0.00, 1.00,  0.00,
               -0.80, 0.00,  0.60 );

// try to get the normal analytically???
// jk this is fur sure too much thinking
vec3 menger_normal( vec3 p, int level ) {
    
    // p starts off between -1 and +1
    // so we must transform p to be between 0 and 1
    p = p / 2.0 + 0.5;

    // figure out direction of normal for all three dimensions
    vec3 normal = vec3(0.0);
    bvec3 set = bvec3(false);
    
    // check if they're outside the box
    for ( int d = 0; d < 3; d++ ) {
        if (p[d] < 0.0) {normal[d] = -1.0; set[d] = true;}
        if (p[d] > 1.0) {normal[d] = 1.0; set[d] = true;}
    }
    
    // now we know we're in the interval [0,1]

    /*for ( int i = 0; i < MAX_RECURSION; i++ ) {
        if ( i >= level ) break;

        // scale up x3
        p = p * 3.0;
        for ( int d = 0; d < 3; d++ ) {
            if ( !set[d] ) {
                if (floor(p[d]) == 1 && round(p[d]) == 1) {normal[d] = 1.0; set[d] = true;}
                if (floor(p[d]) == 1 && round(p[d]) == 2) {normal[d] = -1.0; set[d] = true;}

            }
        } 
    }*/


    return normalize(normal);
}

float menger_de( vec3 p, int level ) {

    // menger sponge
    // source: https://www.shadertoy.com/view/4sX3Rn
    float d = sdBox(p,vec3(1.0));
    float ani = smoothstep( -0.2, 0.2, -cos(0.5*iGlobalTime) );
    float off = 1.5*sin( 0.01*iGlobalTime );
    
    float s = 1.0;
    for( int m=0; m< MAX_RECURSION; m++ )
    {
        if (m >= level) break;

        p = mix( p, ma*(p+off), ani );
       
        vec3 a = mod( p*s, 2.0 )-1.0;
        s *= 3.0;
        vec3 r = abs(1.0 - 3.0*abs(a));
        float da = max(r.x,r.y);
        float db = max(r.y,r.z);
        float dc = max(r.z,r.x);
        float c = (min(da,min(db,dc))-1.0)/s;

        if( c > d ) d = c;
    }

    return d;

}

vec2 complexMult( vec2 a, vec2 b ) {
    return vec2(a.x * b.x - a.y * b.y,
                a.x * b.y + b.x * a.y);
}

float complexModSquared( vec2 a ) {
    return a.x * a.x + a.y * a.y;
}

// http://iquilezles.org/www/articles/distancefractals/distancefractals.htm

float mandelbrot_de( vec3 p ) {
    vec2 c = vec2( p.x, p.y );
    vec2 z = vec2( 0.0, 0.0 );
    vec2 dz = vec2( 0.0, 0.0 ); 

    float m2;
    for( int i=0; i<MAX_MANDEL_ITER; i++ )
    {

        dz = 2.0 * complexMult(z,dz) + vec2(1.0,0.0);
        z = complexMult(z,z) + c;

        m2 = complexModSquared(z);
        if( m2>1e20 ) {
            iter = float(i)/float(MAX_MANDEL_ITER);
            break;
        }
    }

    // distance estimation: G/|G'|
    return sqrt( m2/complexModSquared(dz) )*0.5*log(m2);


}

float julia_de( vec3 p )
{
    // julia_de
    vec2 c = vec2( p.x, p.y );
    vec2 z = vec2( p.z, value );//0.0f, 0.0f );
    vec2 dz = vec2( 1.0, 0.0 ); // Complex dz( 1.0f, 0.0f );

    float m2;
    for( int i=0; i<1024; i++ )
    {
        dz = 2.0 * complexMult(z,dz);
        z = complexMult(z,z) + c;

        m2 = complexModSquared(z);
        if( m2>1e20 )
            break;
    }

    // distance estimation: G/|G'|
    return sqrt( m2/complexModSquared(dz) )*0.5*log(m2);

}

// source: http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/
float tetra_de( vec3 p ) {
    // sierpinski gasket
    /*float Scale = 2.0;
    int Iterations = 1;

    vec3 a1 = vec3(1.0,1.0,1.0);
    vec3 a2 = vec3(-1.0,-1.0,1.0);
    vec3 a3 = vec3(1.0,-1.0,-1.0);
    vec3 a4 = vec3(-1.0,1.0,-1.0);
    vec3 c;
    int n = 0;
    float dist, d;
    for (int n = 0; n < MAX_RECURSION; n++) {
        if (n >= Iterations) break;

        c = a1; dist = length(z-a1);
        d = length(z-a2); if (d < dist) { c = a2; dist=d; }
        d = length(z-a3); if (d < dist) { c = a3; dist=d; }
        d = length(z-a4); if (d < dist) { c = a4; dist=d; }
        z = Scale*z-c*(Scale-1.0);
    }*/
 
    //return length(z) * pow(Scale, float(-n));

/*  , int level, float scale, float offset
    for ( int i = 0; i < MAX_RECURSION; i++ ) {
        if (i >= level) break;
        if (p.x + p.y < 0.0) p.xy = -p.yx; // fold 1
        if (p.x + p.z < 0.0) p.xz = -p.zx; // fold 2
        if (p.y + p.z < 0.0) p.zy = -p.yz; // fold 3

        p = p*scale - offset * (scale - 1.0);
    }

    return length(p) * pow(scale, -float(level));*/
    return 0.0;
}

// finite difference method
// except you can't use functions as arguments to other functions
// so we can't pass in 'sphere_de'. which is annoying
// ughhhh. will fix laters?
vec3 fDiff_infSpheres(vec3 pos, float rad) {

    vec3 dx = vec3(EPS,0.0,0.0);
    
    return normalize(vec3(sphere_de(pos + dx.xyy,rad) - sphere_de(pos - dx.xyy,rad),
            sphere_de(pos + dx.yxy,rad) - sphere_de(pos - dx.yxy,rad),
            sphere_de(pos + dx.yyx,rad) - sphere_de(pos - dx.yyx,rad)));
}

vec3 fDiff_menger(vec3 pos, int level) {

    vec3 dx = vec3(EPS,0.0,0.0);

    return normalize(vec3(menger_de(pos + dx.xyy,level) - menger_de(pos - dx.xyy,level),
            menger_de(pos + dx.yxy,level) - menger_de(pos - dx.yxy,level),
            menger_de(pos + dx.yyx,level) - menger_de(pos - dx.yyx,level)));
}

vec3 fDiff_julia(vec3 pos) {

    vec3 dx = vec3(EPS,0.0,0.0);

    return normalize(vec3(julia_de(pos + dx.xyy) - julia_de(pos - dx.xyy),
            julia_de(pos + dx.yxy) - julia_de(pos - dx.yxy),
            julia_de(pos + dx.yyx) - julia_de(pos - dx.yyx)));
}

vec3 fDiff_mandelbrot(vec3 pos) {

    vec3 dx = vec3(EPS,0.0,0.0);

    return normalize(vec3(mandelbrot_de(pos + dx.xyy) - mandelbrot_de(pos - dx.xyy),
            mandelbrot_de(pos + dx.yxy) - mandelbrot_de(pos - dx.yxy),
            mandelbrot_de(pos + dx.yyx) - mandelbrot_de(pos - dx.yyx)));
}

float findIntersectionWithMenger( vec3 pos, Shape shape, out Intersection intersect) {
    int level = int(shape.v1.x);

    float dist = menger_de(pos,level);

    intersect.position = pos;
    intersect.normal = vec3(0.0);//menger_normal(pos,level);//fDiff_menger(pos,level);
    return dist;
}

float findIntersectionWithJulia( vec3 pos, Shape shape, out Intersection intersect) {
    
    float dist = julia_de(pos);

    intersect.position = pos;
    intersect.normal = fDiff_julia(pos);//vec3(0.0);
    return dist;
}



float findIntersectionWithMandelbrot( vec3 pos, Shape shape, out Intersection intersect) {
    
    float dist = mandelbrot_de(pos);

    intersect.position = pos;
    intersect.normal = fDiff_mandelbrot(pos);//vec3(0.0);
    return dist;
}

float findIntersectionWithInfSphere( vec3 pos, Shape shape, out Intersection intersect) {
    float rad = getShapeRadius(shape);
    
    int xdir = int(abs(pos.x) / (2.0 * rad));
    int zdir = int(abs(pos.z) / (2.0 * rad));
    int raddir = xdir + zdir;//int(sqrt(xdir * xdir + zdir * zdir));

    float tmp = float(raddir) * 4.0/128.;
    vec2 idx = vec2(tmp/4.0,0.0);
    vec4 fourBytes = texture2D(audio,idx);

    float fb;
    int tmp1 = int(mod(tmp,4.0));
    if (tmp1 == 0) fb = fourBytes.x;
    else if (tmp1 == 1) fb = fourBytes.y;
    else if (tmp1 == 2) fb = fourBytes.z;
    else fb = fourBytes.w;

    vec3 modpos = vec3(mod(pos.x,2.0 * rad) - rad,pos.y - fb * 5.0,mod(pos.z,2.0 * rad) - rad); 
    
    float dist = sphere_de( modpos, rad );

    intersect.position = pos;

    // theres something wrong with thissssss. 
    intersect.normal = normalize(modpos); // fDiff_infSpheres(modpos, rad);

    return dist;
}

float findIntersectionWithSphere( vec3 pos, Shape shape, out Intersection intersect) {
    vec3 cen = getShapeCenter(shape);
    float rad = getShapeRadius(shape);

    //pos.y += data0 * 10.0/255.0;
    //pos.y += float(audio[0]) * 10.0/255.0;

    vec3 tmp = pos - cen;
    float dist = sphere_de(tmp,rad);

    intersect.position = pos;
    intersect.normal = normalize(tmp);
    return dist;
}


float findIntersection( vec3 pos, Shape shape, out Intersection intersect ) {
    if( shape.shapeType == INFSPHERE) {
        return findIntersectionWithInfSphere(pos, shape, intersect);
    }
    if( shape.shapeType == SPHERE) {
        return findIntersectionWithSphere(pos, shape, intersect);
    }
    if( shape.shapeType == MENGER) {
        return findIntersectionWithMenger(pos, shape, intersect);
    }
    if( shape.shapeType == JULIA) {
        return findIntersectionWithJulia(pos, shape, intersect);
    }
    if( shape.shapeType == MANDELBROT) {
        return findIntersectionWithMandelbrot(pos, shape, intersect);
    }
    
    return INFINITY;
}

// test ray against each implicit function - union is the min
float rayIntersectScene( Ray ray, out Object obj, out Intersection out_intersect ) {
    
    // initialize distance along ray to 0
    float t = 0.0;

    for ( int i = 0; i < MAX_STEPS; i++ )
    {
        // evaluate the distance to the nearest part of the geometry
        vec3 posIntersection = rayGetOffset( ray, t );
        
        float deltat = INFINITY;
        Intersection intersect;
        for (int j=0; j<MAX_OBJECTS; j++) {
            if ( j>= numObjects ) break;
            
            float cur_dist = findIntersection( posIntersection, objects[j].shape, intersect );
            intersect.steps = i;
            if ( chooseCloserIntersection(cur_dist, deltat, intersect, out_intersect) ) {
                obj = objects[j];
            }
            
        }

        //if ( deltat < EPS && i == 0 ) return -INFINITY;

        if ( deltat < EPS ) return deltat;
        if (deltat < INFINITY) t += deltat;
    }

    return t;
}

// implementation of raymarching algorithm for rendering fractals/other complex geometries
vec3 marchRay( Ray ray ) {
    Object obj;
    Intersection intersect;


    float deltat = rayIntersectScene( ray, obj, intersect );

    // didn't hit anything, or we're inside something - default return black
    if ( deltat == -INFINITY || deltat >= EPS ) {return vec3( 0.0, 0.0, 0.0 );}
    
    // if we're very close to the surface/inside of the geometry
    // now ( deltat < EPS ) :
    // find the normal vector at this position
    // analytically or through finite difference method
    vec3 eyeVector = normalize(ray.origin - intersect.position);           
    if (dot(eyeVector, intersect.normal) < 0.0) { intersect.normal = -intersect.normal; }

    vec3 resColor = calcSpecularColor(obj, intersect.position, intersect.normal, eyeVector, false);
    
    // ambient occlusion (???)
    return (1.0 - float(intersect.steps)/float(MAX_STEPS)) * resColor;
  
    // no ambient occlusion
    //return resColor;
}

void main() {
    float cameraFOV = 0.1;
    vec3 direction = vec3(v_position.x * cameraFOV * width/height, v_position.y * cameraFOV, 1.0);

    Ray ray;
	ray.origin    = vec3( uMVMatrix * vec4(camera, 1.0) );
    ray.direction = vec3( uMVMatrix * vec4(direction, 0.0) );

    // march the ray for this pixel
    vec3 res = marchRay( ray );
    
    // paint the resulting color into this pixel
    gl_FragColor = vec4( res.x, res.y, res.z, 1.0 );
}
